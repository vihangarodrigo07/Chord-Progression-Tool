<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chord Graph - Music Theory Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #ffffff;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 30px;
        }

        .header h1 {
            font-size: 3rem;
            font-weight: 700;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.8;
            line-height: 1.6;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 40px;
        }

        .panel {
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
        }

        .panel:hover {
            transform: translateY(-5px);
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.15);
        }

        .panel h2 {
            font-size: 1.8rem;
            margin-bottom: 20px;
            color: #667eea;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .control-row {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        label {
            font-weight: 600;
            color: #e0e0e0;
            min-width: 80px;
        }

        select, input {
            flex: 1;
            padding: 12px 16px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.05);
            color: #ffffff;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        select:focus, input:focus {
            outline: none;
            border-color: #667eea;
            background: rgba(255, 255, 255, 0.1);
        }

        select option {
            background: #1a1a2e;
            color: #ffffff;
        }

        .btn {
            padding: 14px 28px;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        }

        .btn:active {
            transform: translateY(0);
        }

        .play-btn {
            background: linear-gradient(135deg, #ff6b6b 0%, #ffd93d 100%);
            color: #333;
            font-weight: 700;
            border-radius: 50px;
            padding: 12px 20px;
            margin-left: 10px;
            min-width: 100px;
        }

        .audio-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-top: 15px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .tempo-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .result-area {
            min-height: 200px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            padding: 20px;
            border: 2px dashed rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
        }

        .progression {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin: 20px 0;
        }

        .chord-box {
            padding: 15px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 12px;
            font-weight: 700;
            font-size: 1.1rem;
            color: white;
            min-width: 80px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .chord-box:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }

        .graph-container {
            grid-column: 1 / -1;
            height: 500px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            padding: 20px;
            position: relative;
            overflow: hidden;
        }

        .graph-svg {
            width: 100%;
            height: 100%;
        }

        .chord-node {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .chord-node:hover {
            transform: scale(1.1);
        }

        .chord-edge {
            stroke: rgba(255, 255, 255, 0.3);
            stroke-width: 2;
            transition: all 0.3s ease;
        }

        .chord-edge.highlighted {
            stroke: #667eea;
            stroke-width: 3;
            filter: drop-shadow(0 0 5px #667eea);
        }

        .chord-label {
            fill: #ffffff;
            font-size: 14px;
            font-weight: 600;
            text-anchor: middle;
            dominant-baseline: central;
            pointer-events: none;
        }

        .info-panel {
            grid-column: 1 / -1;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
            border: 2px solid rgba(102, 126, 234, 0.2);
            border-radius: 20px;
            padding: 30px;
        }

        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .feature-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .feature-card h3 {
            color: #667eea;
            margin-bottom: 10px;
            font-size: 1.2rem;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .control-row {
                flex-direction: column;
                align-items: stretch;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎵 Chord Graph System</h1>
            <p>Discover chord progressions and melodic paths through advanced music theory algorithms</p>
        </div>

        <div class="main-content">
            <div class="panel">
                <h2>🎯 Progression Generator</h2>
                <div class="controls">
                    <div class="control-group">
                        <div class="control-row">
                            <label>Start:</label>
                            <select id="startChord">
                                <option value="C">C Major</option>
                                <option value="Dm">D minor</option>
                                <option value="Em">E minor</option>
                                <option value="F">F Major</option>
                                <option value="G">G Major</option>
                                <option value="Am">A minor</option>
                                <option value="Bdim">B diminished</option>
                            </select>
                        </div>
                        <div class="control-row">
                            <label>End:</label>
                            <select id="endChord">
                                <option value="C">C Major</option>
                                <option value="Dm">D minor</option>
                                <option value="Em">E minor</option>
                                <option value="F">F Major</option>
                                <option value="G">G Major</option>
                                <option value="Am">A minor</option>
                                <option value="Bdim">B diminished</option>
                            </select>
                        </div>
                        <div class="control-row">
                            <label>Length:</label>
                            <input type="range" id="progressionLength" min="3" max="8" value="4">
                            <span id="lengthValue">4</span>
                        </div>
                    </div>
                    <button class="btn btn-primary" onclick="generateProgression()">Generate Progression</button>
                    <div class="audio-controls">
                        <button class="btn play-btn" onclick="playProgression()" id="playBtn">▶ Play</button>
                        <div class="tempo-control">
                            <label>BPM:</label>
                            <input type="range" id="tempoSlider" min="60" max="140" value="120" style="width: 100px;">
                            <span id="tempoValue">120</span>
                        </div>
                    </div>
                </div>
                <div class="result-area" id="progressionResult">
                    <p style="opacity: 0.6; text-align: center;">Click "Generate Progression" to discover new chord sequences</p>
                </div>
            </div>

            <div class="panel">
                <h2>🎼 Melodic Pathfinder</h2>
                <div class="controls">
                    <div class="control-group">
                        <div class="control-row">
                            <label>From:</label>
                            <select id="startNote">
                                <option value="C">C</option>
                                <option value="D">D</option>
                                <option value="E">E</option>
                                <option value="F">F</option>
                                <option value="G">G</option>
                                <option value="A">A</option>
                                <option value="B">B</option>
                            </select>
                        </div>
                        <div class="control-row">
                            <label>To:</label>
                            <select id="endNote">
                                <option value="C">C</option>
                                <option value="D">D</option>
                                <option value="E">E</option>
                                <option value="F">F</option>
                                <option value="G" selected>G</option>
                                <option value="A">A</option>
                                <option value="B">B</option>
                            </select>
                        </div>
                        <div class="control-row">
                            <label>Scale:</label>
                            <select id="scaleType">
                                <option value="major">Major</option>
                                <option value="minor">Natural Minor</option>
                                <option value="dorian">Dorian</option>
                                <option value="mixolydian">Mixolydian</option>
                            </select>
                        </div>
                    </div>
                    <button class="btn btn-primary" onclick="findMelodicPath()">Find Melodic Path</button>
                    <div class="audio-controls">
                        <button class="btn play-btn" onclick="playMelody()" id="melodyPlayBtn">▶ Play Melody</button>
                    </div>
                </div>
                <div class="result-area" id="melodicResult">
                    <p style="opacity: 0.6; text-align: center;">Generate a melodic pathway between notes</p>
                </div>
            </div>
        </div>

        <div class="panel graph-container">
            <h2>🕸️ Chord Relationship Graph</h2>
            <svg class="graph-svg" id="chordGraph"></svg>
        </div>

        <div class="panel info-panel">
            <h2>💡 System Features</h2>
            <div class="feature-grid">
                <div class="feature-card">
                    <h3>Graph-Based Analysis</h3>
                    <p>Chords and keys modeled as interconnected nodes with weighted harmonic relationships for intelligent path finding.</p>
                </div>
                <div class="feature-card">
                    <h3>Smart Algorithms</h3>
                    <p>Uses BFS for progression discovery and Dijkstra's algorithm for optimal melodic pathways between notes.</p>
                </div>
                <div class="feature-card">
                    <h3>Interactive Visualization</h3>
                    <p>Real-time graph updates showing chord relationships and progression paths with modern, responsive design.</p>
                </div>
                <div class="feature-card">
                    <h3>Music Theory Integration</h3>
                    <p>Built on solid music theory foundations including circle of fifths, voice leading, and harmonic function analysis.</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Music Theory Data Structure - Graph representation
        class ChordGraph {
            constructor() {
                this.nodes = new Map();
                this.edges = new Map();
                this.initializeGraph();
            }

            initializeGraph() {
                // Define chords in C major
                const chords = [
                    { name: 'C', fullName: 'C Major', function: 'I' },
                    { name: 'Dm', fullName: 'D minor', function: 'ii' },
                    { name: 'Em', fullName: 'E minor', function: 'iii' },
                    { name: 'F', fullName: 'F Major', function: 'IV' },
                    { name: 'G', fullName: 'G Major', function: 'V' },
                    { name: 'Am', fullName: 'A minor', function: 'vi' },
                    { name: 'Bdim', fullName: 'B diminished', function: 'vii°' }
                ];

                chords.forEach(chord => {
                    this.nodes.set(chord.name, chord);
                    this.edges.set(chord.name, new Map());
                });

                // Define harmonic relationships with weights (lower = stronger connection)
                const relationships = [
                    ['C', 'F', 1], ['C', 'G', 1], ['C', 'Am', 2], ['C', 'Em', 3], ['C', 'Dm', 3],
                    ['F', 'C', 1], ['F', 'Dm', 1], ['F', 'G', 2], ['F', 'Am', 2], ['F', 'Bdim', 3],
                    ['G', 'C', 1], ['G', 'Em', 1], ['G', 'Am', 2], ['G', 'F', 2], ['G', 'Dm', 3],
                    ['Am', 'F', 1], ['Am', 'C', 2], ['Am', 'Dm', 2], ['Am', 'G', 2], ['Am', 'Em', 3],
                    ['Dm', 'G', 1], ['Dm', 'F', 1], ['Dm', 'Am', 2], ['Dm', 'Bdim', 2], ['Dm', 'C', 3],
                    ['Em', 'Am', 1], ['Em', 'C', 3], ['Em', 'G', 1], ['Em', 'F', 3], ['Em', 'Dm', 3],
                    ['Bdim', 'C', 1], ['Bdim', 'Em', 2], ['Bdim', 'G', 2], ['Bdim', 'Am', 3]
                ];

                relationships.forEach(([from, to, weight]) => {
                    this.edges.get(from).set(to, weight);
                });
            }

            // BFS for chord progression generation
            findProgression(start, end, length) {
                if (length < 2) return [start, end];
                
                const queue = [[start]];
                const visited = new Set();
                
                while (queue.length > 0) {
                    const currentPath = queue.shift();
                    const lastChord = currentPath[currentPath.length - 1];
                    
                    if (currentPath.length === length - 1) {
                        return [...currentPath, end];
                    }
                    
                    if (currentPath.length < length - 1) {
                        const neighbors = Array.from(this.edges.get(lastChord).keys())
                            .sort((a, b) => this.edges.get(lastChord).get(a) - this.edges.get(lastChord).get(b));
                            
                        for (const neighbor of neighbors.slice(0, 3)) { // Limit branches
                            if (!currentPath.includes(neighbor) || (currentPath.length > 2 && Math.random() > 0.7)) {
                                const newPath = [...currentPath, neighbor];
                                queue.push(newPath);
                            }
                        }
                    }
                }
                
                // Fallback: simple path
                return this.generateSimplePath(start, end, length);
            }

            generateSimplePath(start, end, length) {
                const path = [start];
                let current = start;
                
                for (let i = 1; i < length - 1; i++) {
                    const neighbors = Array.from(this.edges.get(current).keys());
                    const next = neighbors[Math.floor(Math.random() * Math.min(3, neighbors.length))];
                    path.push(next);
                    current = next;
                }
                
                path.push(end);
                return path;
            }

            // Dijkstra's algorithm for melodic paths
            findMelodicPath(startNote, endNote, scaleType) {
                const scale = this.getScale(scaleType);
                const noteToIndex = {};
                scale.forEach((note, index) => noteToIndex[note] = index);
                
                if (!noteToIndex.hasOwnProperty(startNote) || !noteToIndex.hasOwnProperty(endNote)) {
                    return [startNote, endNote];
                }
                
                const distances = {};
                const previous = {};
                const unvisited = new Set(scale);
                
                scale.forEach(note => distances[note] = Infinity);
                distances[startNote] = 0;
                
                while (unvisited.size > 0) {
                    let current = null;
                    for (const node of unvisited) {
                        if (current === null || distances[node] < distances[current]) {
                            current = node;
                        }
                    }
                    
                    if (current === endNote) break;
                    
                    unvisited.delete(current);
                    
                    for (const neighbor of scale) {
                        if (unvisited.has(neighbor)) {
                            const stepDistance = Math.abs(noteToIndex[neighbor] - noteToIndex[current]);
                            const weight = stepDistance === 1 ? 1 : stepDistance === 2 ? 1.5 : 3;
                            const alt = distances[current] + weight;
                            
                            if (alt < distances[neighbor]) {
                                distances[neighbor] = alt;
                                previous[neighbor] = current;
                            }
                        }
                    }
                }
                
                // Reconstruct path
                const path = [];
                let current = endNote;
                while (current !== undefined) {
                    path.unshift(current);
                    current = previous[current];
                }
                
                return path.length > 1 ? path : [startNote, endNote];
            }

            getScale(scaleType) {
                const scales = {
                    'major': ['C', 'D', 'E', 'F', 'G', 'A', 'B'],
                    'minor': ['C', 'D', 'Eb', 'F', 'G', 'Ab', 'Bb'],
                    'dorian': ['C', 'D', 'Eb', 'F', 'G', 'A', 'Bb'],
                    'mixolydian': ['C', 'D', 'E', 'F', 'G', 'A', 'Bb']
                };
                return scales[scaleType] || scales.major;
            }
        }

        // Initialize the chord graph
        const chordGraph = new ChordGraph();
        let currentProgression = [];
        let currentMelody = [];
        
        // Audio System using Tone.js
        class AudioEngine {
            constructor() {
                this.synth = null;
                this.polySynth = null;
                this.isPlaying = false;
                this.initializeAudio();
            }

            async initializeAudio() {
                if (typeof Tone !== 'undefined') {
                    // Create synthesizers
                    this.synth = new Tone.Synth({
                        oscillator: { type: "sine" },
                        envelope: { attack: 0.1, decay: 0.3, sustain: 0.5, release: 0.8 }
                    }).toDestination();

                    this.polySynth = new Tone.PolySynth(Tone.Synth, {
                        oscillator: { type: "sawtooth" },
                        envelope: { attack: 0.02, decay: 0.1, sustain: 0.3, release: 1.2 }
                    }).toDestination();
                }
            }

            async startAudio() {
                if (Tone.context.state !== 'running') {
                    await Tone.start();
                }
            }

            getChordNotes(chordName) {
                const chordMap = {
                    'C': ['C4', 'E4', 'G4'],
                    'Dm': ['D4', 'F4', 'A4'],
                    'Em': ['E4', 'G4', 'B4'],
                    'F': ['F4', 'A4', 'C5'],
                    'G': ['G4', 'B4', 'D5'],
                    'Am': ['A4', 'C5', 'E5'],
                    'Bdim': ['B4', 'D5', 'F5']
                };
                return chordMap[chordName] || ['C4', 'E4', 'G4'];
            }

            async playChordProgression(progression, tempo = 120) {
                if (!this.polySynth) return;
                
                await this.startAudio();
                this.isPlaying = true;
                
                const beatDuration = 60 / tempo;
                Tone.Transport.bpm.value = tempo;

                const part = new Tone.Part((time, chord) => {
                    const notes = this.getChordNotes(chord);
                    this.polySynth.triggerAttackRelease(notes, '2n', time);
                }, progression.map((chord, index) => [index * beatDuration * 2, chord]));

                part.start();
                Tone.Transport.start();

                setTimeout(() => {
                    part.stop();
                    Tone.Transport.stop();
                    this.isPlaying = false;
                    document.getElementById('playBtn').textContent = '▶ Play';
                }, progression.length * beatDuration * 2 * 1000);
            }

            async playMelodyLine(melody, tempo = 120) {
                if (!this.synth) return;
                
                await this.startAudio();
                this.isPlaying = true;
                
                const beatDuration = 60 / tempo;
                
                const part = new Tone.Part((time, note) => {
                    this.synth.triggerAttackRelease(note + '4', '4n', time);
                }, melody.map((note, index) => [index * beatDuration, note]));

                part.start();
                Tone.Transport.start();

                setTimeout(() => {
                    part.stop();
                    Tone.Transport.stop();
                    this.isPlaying = false;
                    document.getElementById('melodyPlayBtn').textContent = '▶ Play Melody';
                }, melody.length * beatDuration * 1000);
            }
        }

        const audioEngine = new AudioEngine();

        // UI Event Handlers
        function generateProgression() {
            const start = document.getElementById('startChord').value;
            const end = document.getElementById('endChord').value;
            const length = parseInt(document.getElementById('progressionLength').value);
            
            const progression = chordGraph.findProgression(start, end, length);
            currentProgression = progression;
            displayProgression(progression);
            highlightPath(progression);
        }

        async function playProgression() {
            if (!currentProgression.length) {
                generateProgression();
            }
            
            const tempo = parseInt(document.getElementById('tempoSlider').value);
            const playBtn = document.getElementById('playBtn');
            
            if (audioEngine.isPlaying) return;
            
            playBtn.textContent = '⏸ Playing...';
            await audioEngine.playChordProgression(currentProgression, tempo);
        }

        function findMelodicPath() {
            const startNote = document.getElementById('startNote').value;
            const endNote = document.getElementById('endNote').value;
            const scaleType = document.getElementById('scaleType').value;
            
            const path = chordGraph.findMelodicPath(startNote, endNote, scaleType);
            currentMelody = path;
            displayMelodicPath(path, scaleType);
        }

        async function playMelody() {
            if (!currentMelody.length) {
                findMelodicPath();
            }
            
            const playBtn = document.getElementById('melodyPlayBtn');
            
            if (audioEngine.isPlaying) return;
            
            playBtn.textContent = '⏸ Playing...';
            await audioEngine.playMelodyLine(currentMelody, 100);
        }

        function displayProgression(progression) {
            const result = document.getElementById('progressionResult');
            result.innerHTML = `
                <h3 style="margin-bottom: 15px; color: #667eea;">Generated Progression:</h3>
                <div class="progression">
                    ${progression.map((chord, index) => `
                        <div class="chord-box" style="animation: slideIn 0.5s ease ${index * 0.1}s both;">
                            ${chord}
                        </div>
                    `).join('')}
                </div>
                <p style="opacity: 0.7; margin-top: 15px;">
                    Roman numerals: ${progression.map(chord => chordGraph.nodes.get(chord)?.function || chord).join(' - ')}
                </p>
            `;
        }

        function displayMelodicPath(path, scaleType) {
            const result = document.getElementById('melodicResult');
            result.innerHTML = `
                <h3 style="margin-bottom: 15px; color: #667eea;">Melodic Path (${scaleType}):</h3>
                <div class="progression">
                    ${path.map((note, index) => `
                        <div class="chord-box" style="background: linear-gradient(135deg, #764ba2 0%, #667eea 100%); animation: slideIn 0.5s ease ${index * 0.1}s both;">
                            ${note}
                        </div>
                    `).join('')}
                </div>
                <p style="opacity: 0.7; margin-top: 15px;">
                    Smooth voice leading path with minimal harmonic distance
                </p>
            `;
        }

        // Graph Visualization
        function drawChordGraph() {
            const svg = document.getElementById('chordGraph');
            const width = svg.clientWidth;
            const height = svg.clientHeight;
            
            svg.innerHTML = '';
            
            // Position chords in a circle
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) * 0.35;
            
            const chords = Array.from(chordGraph.nodes.keys());
            const positions = {};
            
            chords.forEach((chord, index) => {
                const angle = (index * 2 * Math.PI) / chords.length - Math.PI / 2;
                positions[chord] = {
                    x: centerX + radius * Math.cos(angle),
                    y: centerY + radius * Math.sin(angle)
                };
            });
            
            // Draw edges
            chords.forEach(fromChord => {
                const edges = chordGraph.edges.get(fromChord);
                edges.forEach((weight, toChord) => {
                    if (weight <= 2) { // Only show strong relationships
                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line.setAttribute('x1', positions[fromChord].x);
                        line.setAttribute('y1', positions[fromChord].y);
                        line.setAttribute('x2', positions[toChord].x);
                        line.setAttribute('y2', positions[toChord].y);
                        line.setAttribute('class', 'chord-edge');
                        line.setAttribute('data-from', fromChord);
                        line.setAttribute('data-to', toChord);
                        svg.appendChild(line);
                    }
                });
            });
            
            // Draw nodes
            chords.forEach(chord => {
                const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                group.setAttribute('class', 'chord-node');
                
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', positions[chord].x);
                circle.setAttribute('cy', positions[chord].y);
                circle.setAttribute('r', 30);
                circle.setAttribute('fill', 'url(#chordGradient)');
                circle.setAttribute('stroke', 'rgba(255, 255, 255, 0.3)');
                circle.setAttribute('stroke-width', '2');
                
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', positions[chord].x);
                text.setAttribute('y', positions[chord].y);
                text.setAttribute('class', 'chord-label');
                text.textContent = chord;
                
                group.appendChild(circle);
                group.appendChild(text);
                svg.appendChild(group);
            });
            
            // Add gradient definition
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            const gradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
            gradient.setAttribute('id', 'chordGradient');
            gradient.innerHTML = `
                <stop offset="0%" stop-color="#667eea"/>
                <stop offset="100%" stop-color="#764ba2"/>
            `;
            defs.appendChild(gradient);
            svg.insertBefore(defs, svg.firstChild);
        }

        function highlightPath(progression) {
            // Remove previous highlights
            document.querySelectorAll('.chord-edge').forEach(edge => {
                edge.classList.remove('highlighted');
            });
            
            // Highlight path edges
            for (let i = 0; i < progression.length - 1; i++) {
                const from = progression[i];
                const to = progression[i + 1];
                const edge = document.querySelector(`[data-from="${from}"][data-to="${to}"]`);
                if (edge) {
                    edge.classList.add('highlighted');
                    setTimeout(() => edge.classList.add('highlighted'), i * 200);
                }
            }
        }

        // Add CSS animation
        const style = document.createElement('style');
        style.textContent = `
            @keyframes slideIn {
                from {
                    opacity: 0;
                    transform: translateY(20px);
                }
                to {
                    opacity: 1;
                    transform: translateY(0);
                }
            }
        `;
        document.head.appendChild(style);

        // Initialize UI
        document.getElementById('progressionLength').addEventListener('input', function() {
            document.getElementById('lengthValue').textContent = this.value;
        });

        document.getElementById('tempoSlider').addEventListener('input', function() {
            document.getElementById('tempoValue').textContent = this.value;
        });

        // Initialize graph on load
        window.addEventListener('load', function() {
            drawChordGraph();
        });

        window.addEventListener('resize', function() {
            setTimeout(drawChordGraph, 100);
        });
    </script>
</body>
</html>